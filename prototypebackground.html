<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Simple Vampire Survivors Clone</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        color: white;
        font-family: Arial, sans-serif;
      }
      canvas {
        display: block;
      }
      #restartButton {
        display: none;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 10px 20px;
        font-size: 20px;
        cursor: pointer;
      }
      #timer {
        position: absolute;
        top: 10px;
        left: 10px;
        font-size: 20px;
      }
      #coinCounter {
        position: absolute;
        top: 40px;
        left: 10px;
        font-size: 20px;
      }
      #fireRateDisplay {
        position: absolute;
        top: 70px;
        left: 10px;
        font-size: 20px;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas"></canvas>
    <div id="timer">Time: 0</div>
    <div id="coinCounter">Coins: 0</div>
    <div id="fireRateDisplay">Fire Rate: 2.00</div>
    <button id="restartButton">Restart</button>
    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const restartButton = document.getElementById("restartButton");
      const timerElement = document.getElementById("timer");
      const coinCounterElement = document.getElementById("coinCounter");
      const fireRateDisplayElement = document.getElementById("fireRateDisplay");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      // Load images
      const images = {
        player: new Image(),
        enemy: new Image(),
        coin: new Image(),
        background: new Image(),
        tower: new Image(),
      };

      // Set image sources
      images.player.src = "player.png";
      images.enemy.src = "enemy.png";
      images.coin.src = "coin.png";
      images.background.src = "background.png";
      images.tower.src = "tower.png"; // Add a tower image

      // Player
      const player = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        size: 40, // Adjust size based on your image
        speed: 5,
      };

      // Projectiles
      const projectiles = [];
      const projectileSpeed = 8;
      let isShooting = false;
      let fireRate = 2; // Projectiles per second
      const framesPerShot = 60 / fireRate; // Frames between each shot

      // Enemies
      const enemies = [];
      const enemySize = 30; // Adjust size based on your image
      let enemySpeed = 2; // Increased starting speed
      let spawnRate = 1; // Initial spawn rate (5 enemies per second)
      let timeSinceLastSpawn = 0; // Track time since last spawn
      let timeSinceLastShot = 0;

      // Coins
      const coins = [];
      const coinSize = 20; // Adjust size based on your image
      let coinCount = 0;

      // Towers
      const towers = [];
      const towerFireRate = 5; // Fixed fire rate for towers
      const towerRange = 200; // Range of the tower
      const towerSize = 40; // Adjust size based on your image

      // Game state
      let gameOver = false;
      let startTime = null;
      let elapsedTime = 0;

      // Frame rate control
      const fps = 60;
      const frameInterval = 1000 / fps;
      let lastFrameTime = 0;

      // Game Loop
      function gameLoop(timestamp) {
        if (gameOver) return;

        // Cap frame rate
        if (timestamp - lastFrameTime < frameInterval) {
          requestAnimationFrame(gameLoop);
          return;
        }
        lastFrameTime = timestamp;

        // Update timer
        if (!startTime) startTime = timestamp;
        elapsedTime = (timestamp - startTime) / 1000; // Convert to seconds
        timerElement.textContent = `Time: ${elapsedTime.toFixed(1)}`;

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw background
        ctx.drawImage(images.background, 0, 0, canvas.width, canvas.height);

        // Draw player
        ctx.drawImage(
          images.player,
          player.x - player.size / 2,
          player.y - player.size / 2,
          player.size,
          player.size,
        );

        // Draw projectiles
        ctx.fillStyle = "yellow";
        projectiles.forEach((proj, index) => {
          proj.x += proj.vx;
          proj.y += proj.vy;
          ctx.fillRect(
            proj.x - proj.size / 2,
            proj.y - proj.size / 2,
            proj.size,
            proj.size,
          );

          // Remove projectiles that go off-screen
          if (
            proj.x < 0 ||
            proj.x > canvas.width ||
            proj.y < 0 ||
            proj.y > canvas.height
          ) {
            projectiles.splice(index, 1);
          }
        });

        // Spawn enemies based on timer
        timeSinceLastSpawn += frameInterval / 1000; // Convert to seconds
        const timeBetweenSpawns = 1 / spawnRate; // Time between each spawn
        if (timeSinceLastSpawn >= timeBetweenSpawns) {
          spawnEnemy();
          timeSinceLastSpawn = 0; // Reset spawn timer
        }

        // Draw and move enemies
        enemies.forEach((enemy, index) => {
          // Move enemy toward player
          const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
          enemy.x += Math.cos(angle) * enemySpeed;
          enemy.y += Math.sin(angle) * enemySpeed;

          // Draw enemy
          ctx.drawImage(
            images.enemy,
            enemy.x - enemySize / 2,
            enemy.y - enemySize / 2,
            enemySize,
            enemySize,
          );

          // Check for collision with player
          const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
          if (dist < player.size / 2 + enemySize / 2) {
            gameOver = true;
            restartButton.style.display = "block";
          }

          // Check for collision with projectiles
          projectiles.forEach((proj, projIndex) => {
            const projDist = Math.hypot(proj.x - enemy.x, proj.y - enemy.y);
            if (projDist < proj.size / 2 + enemySize / 2) {
              enemies.splice(index, 1);
              projectiles.splice(projIndex, 1);
              dropCoin(enemy.x, enemy.y); // Drop a coin when enemy dies
            }
          });
        });

        // Draw and collect coins
        coins.forEach((coin, index) => {
          ctx.drawImage(
            images.coin,
            coin.x - coinSize / 2,
            coin.y - coinSize / 2,
            coinSize,
            coinSize,
          );

          // Check for collision with player
          const dist = Math.hypot(player.x - coin.x, player.y - coin.y);
          if (dist < player.size / 2 + coinSize / 2) {
            coins.splice(index, 1);
            coinCount++;
            coinCounterElement.textContent = `Coins: ${coinCount}`;
          }
        });

        // Draw and update towers
        towers.forEach((tower, towerIndex) => {
          ctx.drawImage(
            images.tower,
            tower.x - towerSize / 2,
            tower.y - towerSize / 2,
            towerSize,
            towerSize,
          );

          // Find the nearest enemy within range
          let nearestEnemy = null;
          let nearestDistance = towerRange;
          enemies.forEach((enemy) => {
            const dist = Math.hypot(tower.x - enemy.x, tower.y - enemy.y);
            if (dist < nearestDistance) {
              nearestEnemy = enemy;
              nearestDistance = dist;
            }
          });

          // Shoot at the nearest enemy
          if (nearestEnemy) {
            tower.timeSinceLastShot += frameInterval / 1000; // Convert to seconds
            const timeBetweenShots = 1 / towerFireRate;
            if (tower.timeSinceLastShot >= timeBetweenShots) {
              const angle = Math.atan2(
                nearestEnemy.y - tower.y,
                nearestEnemy.x - tower.x,
              );
              const vx = Math.cos(angle) * projectileSpeed;
              const vy = Math.sin(angle) * projectileSpeed;
              projectiles.push({
                x: tower.x,
                y: tower.y,
                size: 5,
                vx,
                vy,
              });
              tower.timeSinceLastShot = 0; // Reset shot timer
            }
          }
        });

        // Shooting logic
        timeSinceLastShot += frameInterval / 1000; // Convert to seconds
        const timeBetweenShots = 1 / fireRate; // Time between each spawn
        if (timeSinceLastShot >= timeBetweenShots && isShooting) {
          shootProjectile();
          timeSinceLastShot = 0; // Reset spawn timer
        }

        // Update fire rate display
        fireRateDisplayElement.textContent = `Fire Rate: ${fireRate.toFixed(2)}`;

        requestAnimationFrame(gameLoop);
      }

      // Spawn an enemy at a random edge of the screen
      function spawnEnemy() {
        const side = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
        let x, y;
        switch (side) {
          case 0: // Top
            x = Math.random() * canvas.width;
            y = -enemySize;
            break;
          case 1: // Right
            x = canvas.width + enemySize;
            y = Math.random() * canvas.height;
            break;
          case 2: // Bottom
            x = Math.random() * canvas.width;
            y = canvas.height + enemySize;
            break;
          case 3: // Left
            x = -enemySize;
            y = Math.random() * canvas.height;
            break;
        }
        enemies.push({ x, y });
      }

      // Drop a coin at the specified position
      function dropCoin(x, y) {
        coins.push({ x, y });
      }

      // Player movement
      const keys = { w: false, a: false, s: false, d: false };
      window.addEventListener("keydown", (e) => {
        if (e.key === "w") keys.w = true;
        if (e.key === "a") keys.a = true;
        if (e.key === "s") keys.s = true;
        if (e.key === "d") keys.d = true;

        // Upgrade fire rate when '1' is pressed
        if (e.key === "1") {
          if (coinCount >= 5) {
            coinCount -= 5;
            fireRate *= 1.1; // Increase fire rate by 10%
            coinCounterElement.textContent = `Coins: ${coinCount}`;
            console.log(`Fire rate upgraded to: ${fireRate.toFixed(2)}`);
          } else {
            console.log("Not enough coins to upgrade!");
          }
        }

        // Place tower when '2' is pressed
        if (e.key === "2") {
          if (coinCount >= 10) {
            coinCount -= 10;
            towers.push({
              x: player.x,
              y: player.y,
              timeSinceLastShot: 0,
            });
            coinCounterElement.textContent = `Coins: ${coinCount}`;
            console.log("Tower placed!");
          } else {
            console.log("Not enough coins to place a tower!");
          }
        }
      });
      window.addEventListener("keyup", (e) => {
        if (e.key === "w") keys.w = false;
        if (e.key === "a") keys.a = false;
        if (e.key === "s") keys.s = false;
        if (e.key === "d") keys.d = false;
      });

      function movePlayer() {
        if (keys.w && player.y > 0) player.y -= player.speed;
        if (keys.a && player.x > 0) player.x -= player.speed;
        if (keys.s && player.y < canvas.height) player.y += player.speed;
        if (keys.d && player.x < canvas.width) player.x += player.speed;
      }

      // Shooting projectiles
      function shootProjectile() {
        const angle = Math.atan2(mouseY - player.y, mouseX - player.x);
        const vx = Math.cos(angle) * projectileSpeed;
        const vy = Math.sin(angle) * projectileSpeed;
        projectiles.push({
          x: player.x,
          y: player.y,
          size: 5,
          vx,
          vy,
        });
      }

      // Mouse position
      let mouseX = 0,
        mouseY = 0;
      window.addEventListener("mousemove", (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
      });

      // Hold to shoot
      window.addEventListener("mousedown", (e) => {
        if (e.button === 0) {
          // Left mouse button
          isShooting = true;
        }
      });
      window.addEventListener("mouseup", (e) => {
        if (e.button === 0) {
          isShooting = false;
        }
      });

      // Restart game
      restartButton.addEventListener("click", () => {
        gameOver = false;
        restartButton.style.display = "none";
        player.x = canvas.width / 2;
        player.y = canvas.height / 2;
        enemies.length = 0;
        projectiles.length = 0;
        coins.length = 0;
        towers.length = 0;
        coinCount = 0;
        coinCounterElement.textContent = `Coins: ${coinCount}`;
        spawnRate = 1; // Reset spawn rate
        fireRate = 2; // Reset fire rate
        startTime = null;
        elapsedTime = 0;
        timeSinceLastSpawn = 0;
        timeSinceLastShot = 0;
        requestAnimationFrame(gameLoop);
      });

      // Update game state
      function update() {
        movePlayer();
      }

      // Start game loop
      setInterval(update, 1000 / 60); // Update 60 times per second
      requestAnimationFrame(gameLoop);
    </script>
  </body>
</html>
