<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Simple Vampire Survivors Clone</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        color: white;
        font-family: Arial, sans-serif;
      }
      canvas {
        display: block;
      }
      #restartButton {
        display: none;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 10px 20px;
        font-size: 20px;
        cursor: pointer;
      }
      #timer {
        position: absolute;
        top: 10px;
        left: 10px;
        font-size: 20px;
      }
      #coinCounter {
        position: absolute;
        top: 40px;
        left: 10px;
        font-size: 20px;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas"></canvas>
    <div id="timer">Time: 0</div>
    <div id="coinCounter">Coins: 0</div>
    <button id="restartButton">Restart</button>
    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const restartButton = document.getElementById("restartButton");
      const timerElement = document.getElementById("timer");
      const coinCounterElement = document.getElementById("coinCounter");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      // Player
      const player = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        size: 20,
        speed: 5,
        color: "blue",
      };

      // Projectiles
      const projectiles = [];
      const projectileSpeed = 8;
      let isShooting = false;
      let fireRate = 2; // Projectiles per second
      const framesPerShot = 60 / fireRate; // Frames between each shot

      // Enemies
      const enemies = [];
      const enemySize = 15;
      let enemySpeed = 2; // Increased starting speed
      let spawnRate = 1; // Initial spawn rate (5 enemies per second)
      let timeSinceLastSpawn = 0; // Track time since last spawn
      let timeSinceLastShot = 0;

      // Coins
      const coins = [];
      let coinCount = 0;

      // Game state
      let gameOver = false;
      let startTime = null;
      let elapsedTime = 0;

      // Frame rate control
      const fps = 60;
      const frameInterval = 1000 / fps;
      let lastFrameTime = 0;

      // Game Loop
      function gameLoop(timestamp) {
        if (gameOver) return;

        // Cap frame rate
        if (timestamp - lastFrameTime < frameInterval) {
          requestAnimationFrame(gameLoop);
          return;
        }
        lastFrameTime = timestamp;

        // Update timer
        if (!startTime) startTime = timestamp;
        elapsedTime = (timestamp - startTime) / 1000; // Convert to seconds
        timerElement.textContent = `Time: ${elapsedTime.toFixed(1)}`;

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw player
        ctx.fillStyle = player.color;
        ctx.fillRect(
          player.x - player.size / 2,
          player.y - player.size / 2,
          player.size,
          player.size,
        );

        // Draw projectiles
        ctx.fillStyle = "yellow";
        projectiles.forEach((proj, index) => {
          proj.x += proj.vx;
          proj.y += proj.vy;
          ctx.fillRect(
            proj.x - proj.size / 2,
            proj.y - proj.size / 2,
            proj.size,
            proj.size,
          );

          // Remove projectiles that go off-screen
          if (
            proj.x < 0 ||
            proj.x > canvas.width ||
            proj.y < 0 ||
            proj.y > canvas.height
          ) {
            projectiles.splice(index, 1);
          }
        });

        // Spawn enemies based on timer
        timeSinceLastSpawn += frameInterval / 1000; // Convert to seconds
        const timeBetweenSpawns = 1 / spawnRate; // Time between each spawn
        if (timeSinceLastSpawn >= timeBetweenSpawns) {
          spawnEnemy();
          timeSinceLastSpawn = 0; // Reset spawn timer
        }

        // Draw and move enemies
        ctx.fillStyle = "red";
        enemies.forEach((enemy, index) => {
          // Move enemy toward player
          const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
          enemy.x += Math.cos(angle) * enemySpeed;
          enemy.y += Math.sin(angle) * enemySpeed;

          // Draw enemy
          ctx.fillRect(
            enemy.x - enemy.size / 2,
            enemy.y - enemy.size / 2,
            enemy.size,
            enemy.size,
          );

          // Check for collision with player
          const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
          if (dist < player.size / 2 + enemy.size / 2) {
            gameOver = true;
            restartButton.style.display = "block";
          }

          // Check for collision with projectiles
          projectiles.forEach((proj, projIndex) => {
            const projDist = Math.hypot(proj.x - enemy.x, proj.y - enemy.y);
            if (projDist < proj.size / 2 + enemy.size / 2) {
              enemies.splice(index, 1);
              projectiles.splice(projIndex, 1);
              dropCoin(enemy.x, enemy.y); // Drop a coin when enemy dies
            }
          });
        });

        // Draw and collect coins
        ctx.fillStyle = "gold";
        coins.forEach((coin, index) => {
          ctx.beginPath();
          ctx.arc(coin.x, coin.y, coin.size / 2, 0, Math.PI * 2);
          ctx.fill();

          // Check for collision with player
          const dist = Math.hypot(player.x - coin.x, player.y - coin.y);
          if (dist < player.size / 2 + coin.size / 2) {
            coins.splice(index, 1);
            coinCount++;
            coinCounterElement.textContent = `Coins: ${coinCount}`;
          }
        });

        // Shooting logic
        timeSinceLastShot += frameInterval / 1000; // Convert to seconds
        const timeBetweenShots = 1 / fireRate; // Time between each spawn
        if (timeSinceLastShot >= timeBetweenShots && isShooting) {
          shootProjectile();
          timeSinceLastShot = 0; // Reset spawn timer
        }

        requestAnimationFrame(gameLoop);
      }

      // Spawn an enemy at a random edge of the screen
      function spawnEnemy() {
        const side = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
        let x, y;
        switch (side) {
          case 0: // Top
            x = Math.random() * canvas.width;
            y = -enemySize;
            break;
          case 1: // Right
            x = canvas.width + enemySize;
            y = Math.random() * canvas.height;
            break;
          case 2: // Bottom
            x = Math.random() * canvas.width;
            y = canvas.height + enemySize;
            break;
          case 3: // Left
            x = -enemySize;
            y = Math.random() * canvas.height;
            break;
        }
        enemies.push({ x, y, size: enemySize });
      }

      // Drop a coin at the specified position
      function dropCoin(x, y) {
        coins.push({ x, y, size: 10 });
      }

      // Player movement
      const keys = { w: false, a: false, s: false, d: false };
      window.addEventListener("keydown", (e) => {
        if (e.key === "w") keys.w = true;
        if (e.key === "a") keys.a = true;
        if (e.key === "s") keys.s = true;
        if (e.key === "d") keys.d = true;

        // Upgrade fire rate when '1' is pressed
        if (e.key === "1") {
          if (coinCount >= 5) {
            coinCount -= 5;
            fireRate *= 1.1; // Increase fire rate by 10%
            coinCounterElement.textContent = `Coins: ${coinCount}`;
            console.log(`Fire rate upgraded to: ${fireRate.toFixed(2)}`);
          } else {
            console.log("Not enough coins to upgrade!");
          }
        }
      });
      window.addEventListener("keyup", (e) => {
        if (e.key === "w") keys.w = false;
        if (e.key === "a") keys.a = false;
        if (e.key === "s") keys.s = false;
        if (e.key === "d") keys.d = false;
      });

      function movePlayer() {
        if (keys.w && player.y > 0) player.y -= player.speed;
        if (keys.a && player.x > 0) player.x -= player.speed;
        if (keys.s && player.y < canvas.height) player.y += player.speed;
        if (keys.d && player.x < canvas.width) player.x += player.speed;
      }

      // Shooting projectiles
      function shootProjectile() {
        const angle = Math.atan2(mouseY - player.y, mouseX - player.x);
        const vx = Math.cos(angle) * projectileSpeed;
        const vy = Math.sin(angle) * projectileSpeed;
        projectiles.push({
          x: player.x,
          y: player.y,
          size: 5,
          vx,
          vy,
        });
      }

      // Mouse position
      let mouseX = 0,
        mouseY = 0;
      window.addEventListener("mousemove", (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
      });

      // Hold to shoot
      window.addEventListener("mousedown", (e) => {
        if (e.button === 0) {
          // Left mouse button
          isShooting = true;
        }
      });
      window.addEventListener("mouseup", (e) => {
        if (e.button === 0) {
          isShooting = false;
        }
      });

      // Restart game
      restartButton.addEventListener("click", () => {
        gameOver = false;
        restartButton.style.display = "none";
        player.x = canvas.width / 2;
        player.y = canvas.height / 2;
        enemies.length = 0;
        projectiles.length = 0;
        coins.length = 0;
        coinCount = 0;
        coinCounterElement.textContent = `Coins: ${coinCount}`;
        spawnRate = 1; // Reset spawn rate
        fireRate = 2; // Reset fire rate
        startTime = null;
        elapsedTime = 0;
        timeSinceLastSpawn = 0;
        timeSinceLastShot = 0;
        requestAnimationFrame(gameLoop);
      });

      // Update game state
      function update() {
        movePlayer();
      }

      // Start game loop
      setInterval(update, 1000 / 60); // Update 60 times per second
      requestAnimationFrame(gameLoop);
    </script>
  </body>
</html>
