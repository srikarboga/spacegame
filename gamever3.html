<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0, user-scalable=no" name="viewport" />
    <title>Spacescape</title>
    <style>
      body { margin: 0; padding: 0; }
      img.responsive { max-width: 100%; max-height: 300px; display: block; margin: auto; }
      html {
        margin: 0; padding: 0; height: 100%; font-family: "Orbitron", sans-serif;
        background-color: #1a1a2e; color: #ffffff; overflow: hidden;
      }
      .screen {
        display: none; height: 100%; width: 100%; position: absolute; top: 0; left: 0;
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      }
      .screen.active { display: flex; flex-direction: column; justify-content: center; align-items: center; }
      canvas { display: block; }
      .container { text-align: center; max-width: 600px; width: 90%; }
      button {
        background: linear-gradient(135deg, #283c86 0%, #45a247 100%); border: 2px solid #fff;
        border-radius: 8px; color: #fff; font-family: "Orbitron", sans-serif; font-size: 18px;
        text-transform: uppercase; text-shadow: 0 0 5px rgba(0, 0, 0, 0.5); box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        padding: 12px 30px; margin: 20px auto 0; display: block; width: 215.15px; cursor: pointer;
        transition: all 0.3s ease;
      }
      button:hover {
        background: linear-gradient(135deg, #45a247 0%, #283c86 100%); transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      }
      #game-title {
        font-size: 2.5em; margin-bottom: 30px; text-transform: uppercase; text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        color: #e94560;
      }
      #game-controls {
        position: fixed; top: 0; left: 0; width: 100%; background-color: rgba(26, 26, 46, 0.8);
        padding: 10px 0; z-index: 101; display: none; text-align: center;
      }
      #game-controls button { display: inline-block; width: auto; padding: 8px 15px; margin: 0 5px; font-size: 14px; }
      #hud {
        position: fixed; top: 50px; left: 0; width: 100%; color: white; padding: 10px; z-index: 100;
        display: none; font-family: "Orbitron", sans-serif;
      }
      #timer, #coinCounter, #fireRateDisplay, #healthDisplay, #hazardWarning {
        font-size: 20px; margin: 5px 10px;
      }
      #game-container {
        position: relative; width: 100%; height: calc(100% - 100px); overflow: hidden;
        background-color: #0f3460; border: 2px solid #e94560; box-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
      }
      #instructions-screen.overlay { background: rgba(0, 0, 0, 0.8); }
      #instructions-screen .container {
        background: #1a1a2e; padding: 20px; border-radius: 10px; box-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
      }
      @media (max-width: 600px) {
        #game-title { font-size: 2em; }
        button { width: 80%; font-size: 16px; }
        #game-controls button { font-size: 12px; padding: 6px 12px; }

      /* Joystick Styles */
      #joystick-container {
        position: absolute;
        bottom: 20px;
        left: 20px;
        width: 100px;
        height: 100px;
        display: none; /* Hidden by default, shown during game */
      }

      #joystick-base {
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 50%;
        position: absolute;
      }

      #joystick-handle {
        width: 40px;
        height: 40px;
        background: #e94560;
        border-radius: 50%;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        transition: none; /* Disable transition for smooth movement */
      }

      /* Action Buttons Styles */
      #action-buttons {
        position: absolute;
        bottom: 20px;
        right: 20px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        display: none; /* Hidden by default, shown during game */
      }

      .action-btn {
        background: linear-gradient(135deg, #283c86 0%, #45a247 100%);
        border: 2px solid #fff;
        border-radius: 8px;
        color: #fff;
        font-family: "Orbitron", sans-serif;
        font-size: 14px;
        padding: 10px 20px;
        text-transform: uppercase;
        text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        cursor: pointer;
        transition: all 0.3s ease;
        touch-action: none; /* Prevent default touch behavior */
      }

      .action-btn:hover {
        background: linear-gradient(135deg, #45a247 0%, #283c86 100%);
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      }

      .action-btn:active {
        transform: translateY(0);
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }

      /* Show controls when game-screen is active */
      #game-screen.active #joystick-container,
      #game-screen.active #action-buttons {
        display: block;
      }

      /* Responsive adjustments */
      @media (max-width: 600px) {
        #joystick-container {
          width: 80px;
          height: 80px;
        }
        #joystick-handle {
          width: 30px;
          height: 30px;
        }
        .action-btn {
          font-size: 12px;
          padding: 8px 15px;
        }
      }
      }
    </style>
  </head>
  <body>
    <img src="loadingscreenimageSpaceEscape.png" alt="Responsive Image" class="responsive">
    <div id="game-controls">
      <button id="game-menu-button">Menu</button>
      <button id="game-restart-button">Restart</button>
      <button id="game-instructions-button">Instructions</button>
    </div>

    <div id="hud">
      <div id="timer">Time: 0</div>
      <div id="coinCounter">Coins: 0</div>
      <div id="fireRateDisplay">Fire Rate: 2.00</div>
      <div id="healthDisplay">Health: 3</div>
      <div id="hazardWarning"></div>
    </div>

    <div id="start-menu-screen" class="active screen">
      <div class="container">
        <h1 id="game-title">Spacescape</h1>
        <button id="play-button">Play</button>
        <button id="settings-button">Settings</button>
        <button id="instructions-button">Instructions</button>
      </div>
    </div>

    <div id="settings-screen" class="screen">
      <div class="container">
        <h2>There are no settings at the moment</h2>
        <button id="settings-back-button">Back</button>
      </div>
    </div>

    <div id="instructions-screen" class="screen">
      <div class="container">
        <h2>Instructions</h2>
        <h3>How to Play:</h3>
        <ul>
          <li>Move with WASD keys</li>
          <li>Aim and shoot with mouse</li>
          <li>Press 1 to upgrade fire rate (costs 5 coins)</li>
          <li>Press 2 to place tower (costs 10 coins)</li>
          <li>Collect coins from defeated enemies</li>
          <li>Avoid hazards: asteroids (shootable), solar flares (speed up enemies), debris (damages all)</li>
        </ul>
        <button id="instructions-back-button">Back</button>
      </div>
    </div>

    <div id="game-screen" class="screen">
      <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <!-- Joystick -->
        <div id="joystick-container">
          <div id="joystick-base"></div>
          <div id="joystick-handle"></div>
        </div>
        <!-- Action Buttons -->
        <div id="action-buttons">
          <button id="turret-button" class="action-btn">Place Turret (10)</button>
          <button id="upgrade-button" class="action-btn">Upgrade Fire Rate (5)</button>
        </div>
      </div>
    </div>

    <div id="game-over-screen" class="screen">
      <div class="container">
        <h2>Game Over</h2>
        <div id="game-over-message"></div>
        <button id="play-again-button">Play Again</button>
        <button id="main-menu-button">Main Menu</button>
      </div>
    </div>

    <!-- ALL AUDIO HTML -->
    <audio id="lobby-music" loop><source src="Cosmic Shadows.mp3" type="audio/mpeg" /></audio>
    <audio id="background-music" loop><source src="background-music.mp3" type="audio/mpeg" /></audio>
    <audio id="gameover-music"><source src="GameOverSound2.wav" type="audio/wav"></audio>
    <audio id="turret-place-sound" src="turret_place.wav"></audio>
    <audio id="turret-death-sound" src="turret_death.mp3"></audio>
    <audio id="turret-shoot-sound" src="ship_shoot.wav"></audio>
    <audio id="ship-move-sound" src="ship_move.mp3" loop></audio>
    <audio id="ship-shoot-sound" src="ship_shoot.wav"></audio>
    <audio id="ship-destroy-sound" src="ship_destroy.mp3"></audio>
    <audio id="attack-upgrade-sound" src="attack_upgrade.wav"></audio>
    <audio id="enemy-death-sound" src="enemy_death.mp3"></audio>
    <!-- Hazard Audio -->
    <audio id="asteroid-hit-sound" src="asteroid_hit.mp3"></audio>
    <audio id="solar-flare-sound" src="solar_flare.mp3"></audio>
    <audio id="debris-sound" src="debris_sound.mp3"></audio>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        class GameUI {
          constructor() {
            this.startMenuScreen = document.getElementById("start-menu-screen");
            this.settingsScreen = document.getElementById("settings-screen");
            this.instructionsScreen = document.getElementById("instructions-screen");
            this.gameScreen = document.getElementById("game-screen");
            this.gameOverScreen = document.getElementById("game-over-screen");
            this.gameControls = document.getElementById("game-controls");
            this.hud = document.getElementById("hud");

            this.canvas = document.getElementById("gameCanvas");
            this.ctx = this.canvas.getContext("2d");
            this.timerElement = document.getElementById("timer");
            this.coinCounterElement = document.getElementById("coinCounter");
            this.fireRateDisplayElement = document.getElementById("fireRateDisplay");
            this.healthDisplayElement = document.getElementById("healthDisplay");
            this.hazardWarningElement = document.getElementById("hazardWarning");

            this.joystickContainer = document.getElementById("joystick-container");
            this.joystickHandle = document.getElementById("joystick-handle");
            this.actionButtons = document.getElementById("action-buttons");

            this.sounds = {
              turretPlacement: document.getElementById("turret-place-sound"),
              turretDeath: document.getElementById("turret-death-sound"),
              turretShoot: document.getElementById("turret-shoot-sound"),
              shipMove: document.getElementById("ship-move-sound"),
              shipShoot: document.getElementById("ship-shoot-sound"),
              shipDestroy: document.getElementById("ship-destroy-sound"),
              attackUpgrade: document.getElementById("attack-upgrade-sound"),
              enemyDeath: document.getElementById("enemy-death-sound"),
              asteroidHit: document.getElementById("asteroid-hit-sound"),
              solarFlare: document.getElementById("solar-flare-sound"),
              debris: document.getElementById("debris-sound"),
            };
          }

          swapToScreen(screen) {
            this.startMenuScreen.classList.remove("active");
            this.settingsScreen.classList.remove("active");
            this.instructionsScreen.classList.remove("active");
            this.gameScreen.classList.remove("active");
            this.gameOverScreen.classList.remove("active");
            screen.classList.add("active");

            if (screen.id === "game-screen") {
              this.hud.style.display = "block";
              this.gameControls.style.display = "block";
              this.joystickContainer.style.display = "block"; // Show joystick
              this.actionButtons.style.display = "flex"; // Show buttons
              this.resizeCanvas();
            } else {
              this.hud.style.display = "none";
              this.gameControls.style.display = "none";
              this.joystickContainer.style.display = "none"; // Hide joystick
              this.actionButtons.style.display = "none"; // Hide buttons
            }
          }

          resetJoystick() {
            this.joystickHandle.style.left = "50%";
            this.joystickHandle.style.top = "50%";
          }

          resizeCanvas() {
            this.canvas.width = window.innerWidth || 800; // Default to 800 if window.innerWidth is 0
            this.canvas.height = window.innerHeight || 600; // Default to 600 if window.innerHeight is 0
          }

          startGame() {
            const backgroundMusic = document.getElementById("background-music");
            backgroundMusic.play().catch((error) => {
                console.warn("Background music failed to play, continuing game:", error); // Use warn instead of error to prevent freeze
            });
            this.swapToScreen(this.gameScreen);
          }

          endGame(backgroundMusic) {
            backgroundMusic.pause();
            backgroundMusic.currentTime = 0;
            const gameOverMusic = document.getElementById("gameover-music");
            gameOverMusic.play().catch((error) => console.error("Error playing game over music:", error));
            this.swapToScreen(this.gameOverScreen);
          }

          mainMenu() { this.swapToScreen(this.startMenuScreen); }
          settings() { this.swapToScreen(this.settingsScreen); }
          instructions() { this.swapToScreen(this.instructionsScreen); }

          updateHUD(time, coins, fireRate, health, hazardWarning) {
            this.timerElement.textContent = `Time: ${time.toFixed(1)}`;
            this.coinCounterElement.textContent = `Coins: ${coins}`;
            this.fireRateDisplayElement.textContent = `Fire Rate: ${fireRate.toFixed(2)}`;
            this.healthDisplayElement.textContent = `Health: ${health}`;
            this.hazardWarningElement.textContent = hazardWarning || "";
          }
        }

        class GameLogic {
          constructor(ui) {
            this.ui = ui;
            this.ctx = ui.ctx;

            this.gameOver = false;
            this.startTime = null;
            this.elapsedTime = 0;
            this.lastFrameTime = 0;
            this.coinCount = 0;
            this.fireRate = 6;
            this.playerHealth = 5;

            this.player = { x: window.innerWidth / 2, y: window.innerHeight / 2, size: 60, speed: 5 };
            this.projectiles = [];
            this.enemies = [];
            this.coins = [];
            this.towers = [];
            this.asteroids = [];
            this.debris = [];
            this.solarFlare = { active: false, warningTime: 0, duration: 0 };
            

            this.projectileSpeed = 10;
            this.projectileDamage = 1;
            this.enemySize = 30;
            this.enemySpeed = 1;
            this.spawnRate = 0.5;
            this.coinSize = 20;
            this.towerSize = 50;
            this.towerRange = 100;
            this.towerFireRate = 6;
            this.asteroidSize = 120;
            this.debrisSize = 5;

            this.isShooting = false;
            this.keys = { w: false, a: false, s: false, d: false };
            this.mouseX = 0;
            this.mouseY = 0;
            this.touchX = 0;
            this.touchY = 0;
            this.isTouching = false;
            this.isMoving = false;
            this.moveSoundPlaying = false;

            this.timeSinceLastSpawn = 0;
            this.timeSinceLastShot = 0;
            this.timeSinceLastHazard = 0;
            this.timeSinceLastNebulaStalker = 0; // MARK: Nebula Stalker Spawn Timer
            this.timeSinceLastZephyrScout = 0;   // MARK: Zephyr Scout Spawn Timer
            this.fps = 60;
            this.frameInterval = 1000 / this.fps;

            this.joystickActive = false;
            this.joystickX = 0;
            this.joystickY = 0;

            this.images = {
              player: new Image(), 
              zephyrScout: new Image(), // Zephyr Scout image
              nebulaStalker: new Image(), // Nebula Stalker image
              solarCharger: new Image(), // Solar Charger image (for future use)
              fractalShard: new Image(), // Fractal Shard image (for future use)
              voidMineLayer: new Image(), // Void Mine Layer image (for future use)
              coin: new Image(),
              background: new Image(), 
              tower: new Image(), 
              asteroid: new Image()
            };
            this.images.player.src = "player.png";
            this.images.zephyrScout.src = "enemy.png"; // Placeholder; replace with actual image
            this.images.nebulaStalker.src = "nebula_stalker.png"; // Placeholder; replace with actual image
            this.images.solarCharger.src = "solarCharger.png"; // Placeholder; replace with actual image
            this.images.fractalShard.src = "fractalShard.png"; // Placeholder; replace with actual image
            this.images.voidMineLayer.src = "voidMineLayer.png"; // Placeholder; replace with actual image
            this.images.coin.src = "coin.png";
            this.images.background.src = "background.png";
            this.images.tower.src = "tower.png";
            this.images.asteroid.src = "asteroid.png";
            
            this.enemyTypes = {
              zephyrScout: { health: 1, speed: 2, zigzagTimer: 0, zigzagDirection: 1, damageToPlayer: 1, damageToTower: 1 },
              nebulaStalker: { health: 3, speed: 2.5, circleRadius: 600, circleAngle: 0, shotTimer: 0, damageToPlayer: 1, damageToTower: 1 },
              solarCharger: { health: 2, speed: 4, slowSpeed: 2, chargeTarget: null, explosionRadius: 50, damageToPlayer: 2, damageToTower: 2, damageToEnemies: 2 },
              fractalShard: { health: 4, speed: 2, spiralAngle: 0, shardHealth: 1, shardSpeed: 1, damageToPlayer: 0.5, damageToTower: 0.5 },
              voidMineLayer: { health: 5, speed: 1.5, mineTimer: 0, maxMines: 3, mineLifespan: 10, damageToPlayer: 1.5, damageToTower: 1.5, damageToEnemies: 1.5 }
            };

            this.setupEventListeners();
          }

          setupEventListeners() {
            window.addEventListener("mousemove", (e) => { this.mouseX = e.clientX; this.mouseY = e.clientY; });
            window.addEventListener("mousedown", (e) => { if (e.button === 0) this.isShooting = true; });
            window.addEventListener("mouseup", (e) => { if (e.button === 0) this.isShooting = false; });
            window.addEventListener("keydown", (e) => {
              if (e.key === "w") this.keys.w = true;
              if (e.key === "a") this.keys.a = true;
              if (e.key === "s") this.keys.s = true;
              if (e.key === "d") this.keys.d = true;
              if (e.key === "1") this.upgradeFireRate();
              if (e.key === "2") this.placeTower();
            });
            window.addEventListener("keyup", (e) => {
              if (e.key === "w") this.keys.w = false;
              if (e.key === "a") this.keys.a = false;
              if (e.key === "s") this.keys.s = false;
              if (e.key === "d") this.keys.d = false;
            });
            window.addEventListener("touchstart", (e) => {
              e.preventDefault();
              this.isTouching = true;
              this.isShooting = true;
              const touch = e.touches[0];
              this.touchX = this.mouseX = touch.clientX;
              this.touchY = this.mouseY = touch.clientY;
            }, { passive: false });
            window.addEventListener("touchmove", (e) => {
              e.preventDefault();
              const touch = e.touches[0];
              this.touchX = this.mouseX = touch.clientX;
              this.touchY = this.mouseY = touch.clientY;
            }, { passive: false });
            window.addEventListener("touchend", (e) => {
              e.preventDefault();
              this.isTouching = false;
              this.isShooting = false;
            }, { passive: false });

            const joystickBase = document.getElementById("joystick-base");
            const joystickHandle = this.ui.joystickHandle;

            joystickBase.addEventListener("touchstart", (e) => {
              e.preventDefault();
              this.joystickActive = true;
            }, { passive: false });

            joystickBase.addEventListener("touchmove", (e) => {
              e.preventDefault();
              if (!this.joystickActive) return;
              const touch = e.touches[0];
              const rect = joystickBase.getBoundingClientRect();
              let dx = touch.clientX - (rect.left + rect.width / 2);
              let dy = touch.clientY - (rect.top + rect.height / 2);
              const distance = Math.sqrt(dx * dx + dy * dy);
              const maxDistance = rect.width / 2 - joystickHandle.offsetWidth / 2;

              if (distance > maxDistance) {
                dx = (dx / distance) * maxDistance;
                dy = (dy / distance) * maxDistance;
              }

              joystickHandle.style.left = `${50 + (dx / rect.width) * 100}%`;
              joystickHandle.style.top = `${50 + (dy / rect.height) * 100}%`;

              this.joystickX = dx / maxDistance;
              this.joystickY = dy / maxDistance;
            }, { passive: false });

            joystickBase.addEventListener("touchend", (e) => {
              e.preventDefault();
              this.joystickActive = false;
              this.joystickX = 0;
              this.joystickY = 0;
              this.ui.resetJoystick();
              this.ui.sounds.shipMove.pause();
              this.ui.sounds.shipMove.currentTime = 0;
              this.moveSoundPlaying = false;
            }, { passive: false });

            // Action button listeners
            document.getElementById("turret-button").addEventListener("touchstart", (e) => {
              e.preventDefault();
              this.placeTower();
            }, { passive: false });

            document.getElementById("upgrade-button").addEventListener("touchstart", (e) => {
              e.preventDefault();
              this.upgradeFireRate();
            }, { passive: false });
          }

          reset() {
            this.gameOver = false;
            this.player.x = window.innerWidth / 2;
            this.player.y = window.innerHeight / 2;
            this.playerHealth = 3;
            this.enemies.length = 0;
            this.projectiles.length = 0;
            this.coins.length = 0;
            this.towers.length = 0;
            this.asteroids.length = 0;
            this.debris.length = 0;
            this.solarFlare = { active: false, warningTime: 0, duration: 0 };
            this.coinCount = 0;
            this.fireRate = 6;
            this.startTime = null;
            this.elapsedTime = 0;
            this.timeSinceLastSpawn = 0;
            this.timeSinceLastShot = 0;
            this.timeSinceLastHazard = 0;
            this.timeSinceLastNebulaStalker = 0; // MARK: Reset Nebula Stalker Spawn Timer
            this.timeSinceLastZephyrScout = 0;   // MARK: Reset Zephyr Scout Spawn Timer

            this.joystickActive = false;
            this.joystickX = 0;
            this.joystickY = 0;
            this.ui.resetJoystick();
          }

          movePlayer() {
            this.isMoving = false;
            // Keyboard movement
            if (this.keys.w && this.player.y > 0) { this.player.y -= this.player.speed; this.isMoving = true; }
            if (this.keys.a && this.player.x > 0) { this.player.x -= this.player.speed; this.isMoving = true; }
            if (this.keys.s && this.player.y < this.ui.canvas.height) { this.player.y += this.player.speed; this.isMoving = true; }
            if (this.keys.d && this.player.x < this.ui.canvas.width) { this.player.x += this.player.speed; this.isMoving = true; }

            // Joystick movement
            if (this.joystickActive) {
              const moveX = this.joystickX * this.player.speed;
              const moveY = this.joystickY * this.player.speed;
              this.player.x = Math.max(0, Math.min(this.ui.canvas.width, this.player.x + moveX));
              this.player.y = Math.max(0, Math.min(this.ui.canvas.height, this.player.y + moveY));
              if (moveX !== 0 || moveY !== 0) this.isMoving = true;
            }

            // Sound handling
            if (this.isMoving && !this.moveSoundPlaying) {
              this.ui.sounds.shipMove.play().catch((error) => console.error("Error playing ship move sound:", error));
              this.moveSoundPlaying = true;
            } else if (!this.isMoving) {
              this.ui.sounds.shipMove.pause();
              this.ui.sounds.shipMove.currentTime = 0;
              this.moveSoundPlaying = false;
            }
          }

          shootProjectile() {
            const angle = Math.atan2(this.mouseY - this.player.y, this.mouseX - this.player.x);
            const vx = Math.cos(angle) * this.projectileSpeed;
            const vy = Math.sin(angle) * this.projectileSpeed;
            this.projectiles.push({ x: this.player.x, y: this.player.y, size: 5, vx, vy, type: 'playerShot', source: 'player' });
            this.ui.sounds.shipShoot.play().catch((error) => console.error("Error playing ship shoot sound:", error));
          }

          spawnEnemy() {
            const canvasWidth = this.ui.canvas.width || 800;
            const canvasHeight = this.ui.canvas.height || 600;
            const side = Math.floor(Math.random() * 4);
            let x, y;
            switch (side) {
                case 0: x = Math.random() * canvasWidth; y = -this.enemySize; break;
                case 1: x = canvasWidth + this.enemySize; y = Math.random() * canvasHeight; break;
                case 2: x = Math.random() * canvasWidth; y = canvasHeight + this.enemySize; break;
                case 3: x = -this.enemySize; y = Math.random() * canvasHeight; break;
            }
            const type = Math.random() < 0.1 ? 'nebulaStalker' : 'zephyrScout'; //
            this.enemies.push({ 
              x, y, 
              health: this.enemyTypes[type].health, 
              type, 
              zigzagTimer: type === 'zephyrScout' ? 0 : undefined,  // Zephyr-specific
              zigzagDirection: type === 'zephyrScout' ? 1 : undefined, // Zephyr-specific
              circleRadius: type === 'nebulaStalker' ? this.enemyTypes.nebulaStalker.circleRadius : undefined, 
              circleAngle: type === 'nebulaStalker' ? Math.random() * 2 * Math.PI : undefined, // Random starting angle
              shotTimer: type === 'nebulaStalker' ? 0 : undefined 
            });
          }

          // MARK: New Method - Spawn Nebula Stalker Separately (Optional, for more control)
          spawnNebulaStalker() {
            const canvasWidth = this.ui.canvas.width || 800;
            const canvasHeight = this.ui.canvas.height || 600;
            const side = Math.floor(Math.random() * 4);
            let x, y;
            switch (side) {
              case 0: x = Math.random() * canvasWidth; y = -this.enemySize; break;
              case 1: x = canvasWidth + this.enemySize; y = Math.random() * canvasHeight; break;
              case 2: x = Math.random() * canvasWidth; y = canvasHeight + this.enemySize; break;
              case 3: x = -this.enemySize; y = Math.random() * canvasHeight; break;
            }
            this.enemies.push({ 
              x, y, 
              health: this.enemyTypes.nebulaStalker.health, 
              type: 'nebulaStalker', 
              circleRadius: this.enemyTypes.nebulaStalker.circleRadius,  
              circleAngle: Math.random() * 2 * Math.PI, 
              shotTimer: 0 
            });
          }

          // MARK: New Method - Spawn Zephyr Scout Separately (Optional, for more control)
          spawnZephyrScout() {
            const canvasWidth = this.ui.canvas.width || 800;
            const canvasHeight = this.ui.canvas.height || 600;
            const side = Math.floor(Math.random() * 4);
            let x, y;
            switch (side) {
              case 0: x = Math.random() * canvasWidth; y = -this.enemySize; break;
              case 1: x = canvasWidth + this.enemySize; y = Math.random() * canvasHeight; break;
              case 2: x = Math.random() * canvasWidth; y = canvasHeight + this.enemySize; break;
              case 3: x = -this.enemySize; y = Math.random() * canvasHeight; break;
            }
            this.enemies.push({ 
              x, y, 
              health: this.enemyTypes.zephyrScout.health, 
              type: 'zephyrScout', 
              zigzagTimer: 0, 
              zigzagDirection: 1 
            });
          }

          spawnAsteroid() {
            const canvasWidth = this.ui.canvas.width || 800; // Default to 800 if undefined
            const canvasHeight = this.ui.canvas.height || 600; // Default to 600 if undefined
            const x = Math.random() * canvasWidth;
            const y = Math.random() * canvasHeight;
            const angle = Math.random() * 2 * Math.PI;
            this.asteroids.push({ x, y, vx: Math.cos(angle) * 1, vy: Math.sin(angle) * 1, health: 2 });
          }

          spawnDebris() {
            const canvasWidth = this.ui.canvas.width || 800;
            const canvasHeight = this.ui.canvas.height || 600;
            const side = Math.floor(Math.random() * 4);
            let x, y, vx, vy;
            switch (side) {
                case 0: x = Math.random() * canvasWidth; y = -this.debrisSize; vx = 0; vy = 4; break;
                case 1: x = canvasWidth + this.debrisSize; y = Math.random() * canvasHeight; vx = -4; vy = 0; break;
                case 2: x = Math.random() * canvasWidth; y = canvasHeight + this.debrisSize; vx = 0; vy = -4; break;
                case 3: x = -this.debrisSize; y = Math.random() * canvasHeight; vx = 4; vy = 0; break;
            }
            for (let i = 0; i < 20; i++) {
                this.debris.push({ x: x + Math.random() * 50 - 25, y: y + Math.random() * 50 - 25, vx, vy });
            }
            this.ui.sounds.debris.play().catch((error) => console.error("Error playing debris sound:", error));
          }

          triggerSolarFlare() {
            this.solarFlare.warningTime = 3; // 3-second warning
            this.ui.sounds.solarFlare.play().catch((error) => console.error("Error playing solar flare sound:", error));
          }

          dropCoin(x, y) {
            this.coins.push({ x, y });
          }

          upgradeFireRate() {
            if (this.coinCount >= 5) {
              this.coinCount -= 5;
              this.fireRate *= 1.1;
              this.ui.sounds.attackUpgrade.play().catch((error) => console.error("Error playing attack upgrade sound:", error));
            }
          }

          placeTower() {
            if (this.coinCount >= 10) {
              this.coinCount -= 10;
              this.towers.push({ x: this.player.x, y: this.player.y, timeSinceLastShot: 0, health: 5 });
              this.ui.sounds.turretPlacement.play().catch((error) => console.error("Error playing turret placement sound:", error));
            }
          }

          // MARK: Nebula Stalker Behavior Update
          updateNebulaStalker(enemy) {
            //closest enemy logic
            let target = this.player;
            let closestDist = Math.hypot(enemy.x - this.player.x, enemy.y - this.player.y);
            if (this.towers.length > 0) {
              this.towers.forEach(tower => {
                let towerDist = Math.hypot(enemy.x - tower.x, enemy.y - tower.y);
                if (towerDist < closestDist) { target = tower; closestDist = towerDist; }
              });
            }
            const currentEnemySpeed = this.solarFlare.active ? this.enemySpeed * 2 : this.enemySpeed;
            //shooting logic
            enemy.shotTimer += this.frameInterval / 1000;
            if (enemy.shotTimer >= 5) { // Shoot every 5 seconds
              const angleToTarget = Math.atan2(target.y - enemy.y, target.x - enemy.x);
              const vx = Math.cos(angleToTarget) * 3; // Slow homing projectile
              const vy = Math.sin(angleToTarget) * 3;
              this.projectiles.push({ 
                x: enemy.x, y: enemy.y, size: 10, vx, vy, type: 'nebulaShot', 
                targetX: target.x, targetY: target.y, source: 'enemy' 
              });
              enemy.shotTimer = 0;
            }
            // Calculate current distance to target
              const currentDistance = Math.hypot(target.x - enemy.x, target.y - enemy.y);

            // Initialize previousDistance if not set
            if (!enemy.previousDistance) {
              enemy.previousDistance = currentDistance;
            }

            // Check if the nebulaStalker is moving away
            const isMovingAway = currentDistance > enemy.previousDistance;

            // Update previousDistance for the next frame
            enemy.previousDistance = currentDistance;

            // Update circling parameters
            const angularSpeed = (0.01 * currentEnemySpeed) / (enemy.circleRadius / 100);
            enemy.circleAngle += angularSpeed;

            // Adjust radius decrease rate for spiraling
            const baseDecrement = 0.75 * currentEnemySpeed; // Normal rate of radius decrease
            const spiralMultiplier = isMovingAway ? 2 : 1;   // Faster decrease when moving away
            enemy.circleRadius = Math.max(50, enemy.circleRadius - baseDecrement * spiralMultiplier);

            // Calculate desired position on the circling path
            const desiredX = target.x + Math.cos(enemy.circleAngle) * enemy.circleRadius;
            const desiredY = target.y + Math.sin(enemy.circleAngle) * enemy.circleRadius;

            // Move toward the desired position
            const dx = desiredX - enemy.x;
            const dy = desiredY - enemy.y;
            const distanceToDesired = Math.hypot(dx, dy);
            if (distanceToDesired > 0) {
              const moveSpeed = currentEnemySpeed * 2; // Adjustable movement speed
              const moveX = (dx / distanceToDesired) * moveSpeed;
              const moveY = (dy / distanceToDesired) * moveSpeed;
              enemy.x += moveX;
              enemy.y += moveY;
            }
          }

          // MARK: Zephyr Scout Behavior Update
          updateZephyrScout(enemy) {
            let target = this.player;
            let closestDist = Math.hypot(enemy.x - target.x, enemy.y - target.y);
            if (this.towers.length > 0) {
              this.towers.forEach(tower => {
                let towerDist = Math.hypot(enemy.x - tower.x, enemy.y - tower.y);
                if (towerDist < closestDist) { target = tower; closestDist = towerDist; }
              });
            }
            const currentEnemySpeed = this.solarFlare.active ? this.enemySpeed * 2 : this.enemySpeed;
            enemy.zigzagTimer += this.frameInterval / 1000;
            if (enemy.zigzagTimer >= 1) { // Zigzag every 1 second
              enemy.zigzagDirection *= -1;
              enemy.zigzagTimer = 0;
            }
            // Add horizontal zigzag (10 pixels side to side)
            const angle = Math.atan2(target.y - enemy.y, target.x - enemy.x);
            enemy.x += Math.cos(angle) * currentEnemySpeed + (enemy.zigzagDirection * 10 * (this.frameInterval / 1000) * this.enemyTypes.zephyrScout.speed);
            enemy.y += Math.sin(angle) * currentEnemySpeed;
          }

          update(timestamp) {
            if (this.gameOver) return;

            if (!this.startTime) this.startTime = timestamp;
            this.elapsedTime = (timestamp - this.startTime) / 1000;

            this.movePlayer();

            // Spawn enemies (including Nebula Stalker and Zephyr Scout)
            this.timeSinceLastSpawn += this.frameInterval / 1000;
            if (this.timeSinceLastSpawn >= 1 / this.spawnRate) {
                this.spawnEnemy(); // Updated elsewhere to include new types
                //console.log("Spawned enemy at:", this.enemies[this.enemies.length - 1]);
                this.timeSinceLastSpawn = 0;
            }

            // MARK: Spawn Nebula Stalker
            this.timeSinceLastNebulaStalker += this.frameInterval / 1000;
            if (this.timeSinceLastNebulaStalker >= Math.random() * 10 + 15) { // Rarer spawn (15-25 seconds)
              this.spawnNebulaStalker();
              this.timeSinceLastNebulaStalker = 0;
            }

            // MARK: Spawn Zephyr Scout
            this.timeSinceLastZephyrScout += this.frameInterval / 1000;
            if (this.timeSinceLastZephyrScout >= Math.random() * 5 + 10) { // More frequent spawn (10-15 seconds)
              this.spawnZephyrScout();
              this.timeSinceLastZephyrScout = 0;
            }

            // Shooting logic
            const currentFireRate = this.solarFlare.active ? this.fireRate / 2 : this.fireRate;
            this.timeSinceLastShot += this.frameInterval / 1000;
            if (this.timeSinceLastShot >= 1 / currentFireRate && this.isShooting) {
                this.shootProjectile();
                this.timeSinceLastShot = 0;
            }

            // Hazard spawning
            this.timeSinceLastHazard += this.frameInterval / 1000;
            if (this.timeSinceLastHazard >= Math.random() * 5 + 15) {
                const hazard = Math.floor(Math.random() * 3);
                if (hazard === 0) {
                    this.spawnAsteroid();
                    console.log("Spawned asteroid at:", this.asteroids[this.asteroids.length - 1]);
                } else if (hazard === 1) {
                    this.triggerSolarFlare();
                    console.log("Triggered solar flare");
                } else {
                    this.spawnDebris();
                    console.log("Spawned debris cluster");
                }
                this.timeSinceLastHazard = 0;
            }

            // Solar flare logic
            let hazardWarning = "";
            if (this.solarFlare.warningTime > 0) {
                this.solarFlare.warningTime -= this.frameInterval / 1000;
                hazardWarning = "Solar Flare Incoming!";
                if (this.solarFlare.warningTime <= 0) {
                    this.solarFlare.active = true;
                    this.solarFlare.duration = 5; // 5-second duration
                }
            }
            if (this.solarFlare.active) {
                this.solarFlare.duration -= this.frameInterval / 1000;
                if (this.solarFlare.duration <= 0) this.solarFlare.active = false;
            }

            // MARK: Update Nebula Stalker and Zephyr Scout Behaviors
            this.enemies.forEach(enemy => {
              if (enemy.type === 'nebulaStalker') {
                this.updateNebulaStalker(enemy);
              } else if (enemy.type === 'zephyrScout') {
                this.updateZephyrScout(enemy);
              }
            });

            this.ui.updateHUD(this.elapsedTime, this.coinCount, currentFireRate, this.playerHealth, hazardWarning);
        }

          draw() {
            const backgroundMusic = document.getElementById("background-music");
            const ctx = this.ui.ctx;
            ctx.clearRect(0, 0, this.ui.canvas.width, this.ui.canvas.height);

            ctx.drawImage(this.images.background, 0, 0, this.ui.canvas.width, this.ui.canvas.height);

            // Draw player
            const angle = Math.atan2(this.mouseY - this.player.y, this.mouseX - this.player.x);
            ctx.save();
            ctx.translate(this.player.x, this.player.y);
            ctx.rotate(angle);
            ctx.drawImage(this.images.player, -this.player.size / 2, -this.player.size / 2, this.player.size, this.player.size);
            ctx.restore();

            // Draw projectiles
            
            const projectilesToRemove = [];
            this.projectiles.forEach((proj, index) => {
              if (proj.type === 'nebulaShot' && proj.source === 'enemy') {
                // Homing behavior
                const angleToTarget = Math.atan2(proj.targetY - proj.y, proj.targetX - proj.x);
                proj.vx += Math.cos(angleToTarget) * 0.1; // Gradual direction adjustment
                proj.vy += Math.sin(angleToTarget) * 0.1;
                proj.x += proj.vx;
                proj.y += proj.vy;
                ctx.fillStyle = "purple"; // Distinct color for Nebula shots
                ctx.fillRect(proj.x - proj.size / 2, proj.y - proj.size / 2, proj.size, proj.size);
                //Nebula collision player
                const playerDist = Math.hypot(proj.x - this.player.x, proj.y - this.player.y);
                if (playerDist < this.player.size / 2 + proj.size / 2) {
                  this.playerHealth -= 1; // Adjust damage amount as needed (currently 1 HP)
                  this.projectiles.splice(index, 1); // Remove projectile on hit
                  if (this.playerHealth <= 0) {
                    this.gameOver = true;
                    this.ui.endGame(backgroundMusic);
                    this.ui.sounds.shipDestroy.play().catch((error) => console.error("Error playing sound:", error));
                  }
                  return; // Exit loop for this projectile since it’s removed
                }

                // Nebula Collision with turrets
                this.towers.forEach((tower, tIndex) => {
                  const towerDist = Math.hypot(proj.x - tower.x, proj.y - tower.y);
                  if (towerDist < this.towerSize / 2 + proj.size / 2) {
                    tower.health -= 1; // Adjust damage amount as needed (currently 1 HP)
                    this.projectiles.splice(index, 1); // Remove projectile on hit
                    if (tower.health <= 0) {
                      this.towers.splice(tIndex, 1); // Remove destroyed turret
                    }
                    return; // Exit tower loop for this projectile
                  }
                });
              } else if (proj.source === 'player' || proj.source === 'turret') {
                proj.x += proj.vx;
                proj.y += proj.vy;
                ctx.fillStyle = "yellow"; 
                ctx.fillRect(proj.x - proj.size / 2, proj.y - proj.size / 2, proj.size, proj.size);
              }
              if (proj.x < 0 || proj.x > this.ui.canvas.width || proj.y < 0 || proj.y > this.ui.canvas.height) {
                projectilesToRemove.push(index);
              }
            });

            // Draw enemies
            const currentEnemySpeed = this.solarFlare.active ? this.enemySpeed * 2 : this.enemySpeed;
            const enemiesToRemove = [];
            this.enemies.forEach((enemy, index) => {
                //Draw enemy
                if (enemy.type === 'nebulaStalker') {
                  ctx.drawImage(this.images.nebulaStalker, enemy.x - this.enemySize / 2, enemy.y - this.enemySize / 2, this.enemySize, this.enemySize);
                } else if (enemy.type === 'solarCharger') {
                  ctx.drawImage(this.images.solarCharger, enemy.x - this.enemySize / 2, enemy.y - this.enemySize / 2, this.enemySize, this.enemySize);
                } else if (enemy.type === 'fractalShard') {
                  ctx.drawImage(this.images.fractalShard, enemy.x - this.enemySize / 2, enemy.y - this.enemySize / 2, this.enemySize, this.enemySize);
                } else if (enemy.type === 'voidMineLayer') {
                  ctx.drawImage(this.images.voidMineLayer, enemy.x - this.enemySize / 2, enemy.y - this.enemySize / 2, this.enemySize, this.enemySize);
                } else {
                  ctx.drawImage(this.images.zephyrScout, enemy.x - this.enemySize / 2, enemy.y - this.enemySize / 2, this.enemySize, this.enemySize); // Fallback to Zephyr Scout for undefined types
                }
                //collision player
                const dist = Math.hypot(this.player.x - enemy.x, this.player.y - enemy.y);
                if (dist < this.player.size / 2 + this.enemySize / 2) {
                  const damage = this.enemyTypes[enemy.type].damageToPlayer;
                  this.playerHealth -= damage;
                  enemiesToRemove.push(index);
                  if (this.playerHealth <= 0) {
                    this.gameOver = true;
                    this.ui.endGame(backgroundMusic);
                    this.ui.sounds.shipDestroy.play().catch((error) => console.error("Error playing ship destroy sound:", error));
                  }
                }
                //collision towers
                if (this.towers.length > 0) {
                    const towersToRemove = []; // New array for tower removals
                    this.towers.forEach((tower, tIndex) => {
                        const towerDist = Math.hypot(enemy.x - tower.x, enemy.y - tower.y);
                        if (towerDist < this.towerSize / 2 + this.enemySize / 2) {
                          const damage = this.enemyTypes[enemy.type].damageToTower;
                          // Ensure tower.health doesn't become NaN (fix for issue 2 below)
                          if (isNaN(tower.health)) tower.health = 0; // Reset to default health if NaN
                          tower.health = Math.max(0, tower.health - damage); // Prevent negative health
                            if (tower.health <= 0) {
                                towersToRemove.push(tIndex); // Collect tower index for removal
                            }
                            enemiesToRemove.push(index);
                        }
                    });
                    // Apply tower removals immediately to avoid nested loop issues
                    towersToRemove.sort((a, b) => b - a).forEach(tIndex => this.towers.splice(tIndex, 1));
                }

                // Check collisions with projectiles (apply damage and track health)
                this.projectiles.forEach((proj, projIndex) => {
                  const projDist = Math.hypot(proj.x - enemy.x, proj.y - enemy.y);
                  if (projDist < proj.size / 2 + this.enemySize / 2 && (proj.source === 'player' || proj.source === 'turret')) {
                    // Reduce enemy health by projectile damage (only for player/turret shots)
                    enemy.health -= this.projectileDamage; // Default projectile damage is 1 HP
                    projectilesToRemove.push(projIndex);
                    if (enemy.health <= 0) { // Only remove if health is depleted
                      enemiesToRemove.push(index);
                      this.ui.sounds.enemyDeath.play().catch((error) => console.error("Error playing enemy death sound:", error));
                      this.dropCoin(enemy.x, enemy.y);
                    }
                  }
                });
              });

            // Draw coins (Updated for safety)
            const coinsToRemove = [];
            this.coins.forEach((coin, index) => {
                ctx.drawImage(this.images.coin, coin.x - this.coinSize / 2, coin.y - this.coinSize / 2, this.coinSize, this.coinSize);
                const dist = Math.hypot(this.player.x - coin.x, this.player.y - coin.y);
                if (dist < this.player.size / 2 + this.coinSize / 2) {
                    // Ensure index is valid before pushing
                    if (index >= 0 && index < this.coins.length) {
                        coinsToRemove.push(index);
                        this.coinCount++;
                    }
                }
            });

            // Draw towers
            const towersToRemoveFinal = []; // Collect any additional tower removals from other hazards
            this.towers.forEach((tower) => {
                ctx.drawImage(this.images.tower, tower.x - this.towerSize / 2, tower.y - this.towerSize / 2, this.towerSize, this.towerSize);
                ctx.fillStyle = "red";
                ctx.fillRect(tower.x - 25, tower.y - 35, 50 * (tower.health / 5), 5);
                ctx.fillStyle = "white";
                ctx.font = "14px Arial";
                ctx.fillText(`HP: ${tower.health}`, tower.x - 15, tower.y - 40);

                let nearestEnemy = null;
                let nearestDistance = this.towerRange;
                this.enemies.forEach((enemy) => {
                    const dist = Math.hypot(tower.x - enemy.x, tower.y - enemy.y);
                    if (dist < nearestDistance) { nearestEnemy = enemy; nearestDistance = dist; }
                });

                if (nearestEnemy) {
                    tower.timeSinceLastShot += this.frameInterval / 1000;
                    const towerFireRate = this.solarFlare.active ? this.towerFireRate / 2 : this.towerFireRate;
                    if (tower.timeSinceLastShot >= 1 / towerFireRate) {
                        const angle = Math.atan2(nearestEnemy.y - tower.y, nearestEnemy.x - tower.x);
                        const vx = Math.cos(angle) * this.projectileSpeed;
                        const vy = Math.sin(angle) * this.projectileSpeed;
                        this.projectiles.push({ x: tower.x, y: tower.y, size: 5, vx, vy });
                        this.ui.sounds.turretShoot.play().catch((error) => console.error("Error playing turret shoot sound:", error));
                        tower.timeSinceLastShot = 0;
                    }
                }
            });

            // Draw asteroids
            const asteroidsToRemove = [];
            this.asteroids.forEach((asteroid, index) => {
                asteroid.x += asteroid.vx;
                asteroid.y += asteroid.vy;
                ctx.drawImage(this.images.asteroid, asteroid.x - this.asteroidSize / 2, asteroid.y - this.asteroidSize / 2, this.asteroidSize, this.asteroidSize);

                const playerDist = Math.hypot(this.player.x - asteroid.x, this.player.y - asteroid.y);
                if (playerDist < this.player.size / 2 + this.asteroidSize / 2 && this.playerHealth > 0) {
                    this.playerHealth -= 1;
                    asteroidsToRemove.push(index);
                    this.ui.sounds.asteroidHit.play().catch((error) => console.error("Error playing asteroid hit sound:", error));
                }

                this.towers.forEach((tower, tIndex) => {
                    const towerDist = Math.hypot(tower.x - asteroid.x, tower.y - asteroid.y);
                    if (towerDist < this.towerSize / 2 + this.asteroidSize / 2) {
                        tower.health -= 1;
                        asteroidsToRemove.push(index);
                        if (tower.health <= 0) {
                            towersToRemoveFinal.push(tIndex);
                        }
                    }
                });

                this.enemies.forEach((enemy, eIndex) => {
                    const enemyDist = Math.hypot(enemy.x - asteroid.x, enemy.y - asteroid.y);
                    if (enemyDist < this.enemySize / 2 + this.asteroidSize / 2) {
                        enemiesToRemove.push(eIndex);
                        this.dropCoin(enemy.x, enemy.y);
                        this.ui.sounds.enemyDeath.play().catch((error) => console.error("Error playing enemy death sound:", error));
                    }
                });

                this.projectiles.forEach((proj, pIndex) => {
                    const projDist = Math.hypot(proj.x - asteroid.x, proj.y - asteroid.y);
                    if (projDist < proj.size / 2 + this.asteroidSize / 2) {
                        asteroid.health -= 1;
                        projectilesToRemove.push(pIndex);
                        if (asteroid.health <= 0) {
                            asteroidsToRemove.push(index);
                            //old feature this.dropCoin(asteroid.x, asteroid.y);
                            this.playerHealth+=1
                            this.ui.sounds.asteroidHit.play().catch((error) => console.error("Error playing asteroid hit sound:", error));
                        }
                    }
                });

                if (asteroid.x < -this.asteroidSize || asteroid.x > this.ui.canvas.width + this.asteroidSize ||
                    asteroid.y < -this.asteroidSize || asteroid.y > this.ui.canvas.height + this.asteroidSize) {
                    asteroidsToRemove.push(index);
                }
            });

            // Draw debris
            const debrisToRemove = [];
            this.debris.forEach((particle, index) => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                ctx.fillStyle = "gray";
                ctx.fillRect(particle.x - this.debrisSize / 2, particle.y - this.debrisSize / 2, this.debrisSize, this.debrisSize);

                const playerDist = Math.hypot(this.player.x - particle.x, this.player.y - particle.y);
                if (playerDist < this.player.size / 2 + this.debrisSize / 2 && this.playerHealth > 0) {
                    this.playerHealth -= 0.5;
                    debrisToRemove.push(index);
                }

                this.towers.forEach((tower, tIndex) => {
                    const towerDist = Math.hypot(tower.x - particle.x, tower.y - particle.y);
                    if (towerDist < this.towerSize / 2 + this.debrisSize / 2) {
                        tower.health -= 0.5;
                        debrisToRemove.push(index);
                        if (tower.health <= 0) {
                            towersToRemoveFinal.push(tIndex);
                        }
                    }
                });

                this.enemies.forEach((enemy, eIndex) => {
                    const enemyDist = Math.hypot(enemy.x - particle.x, enemy.y - particle.y);
                    if (enemyDist < this.enemySize / 2 + this.debrisSize / 2) {
                        enemy.health -= 0.5;
                        debrisToRemove.push(index);
                        if (enemy.health <= 0) {
                            enemiesToRemove.push(eIndex);
                            this.dropCoin(enemy.x, enemy.y);
                            this.ui.sounds.enemyDeath.play().catch((error) => console.error("Error playing enemy death sound:", error));
                        }
                    }
                });

                if (particle.x < -this.debrisSize || particle.x > this.ui.canvas.width + this.debrisSize ||
                    particle.y < -this.debrisSize || particle.y > this.ui.canvas.height + this.debrisSize) {
                    debrisToRemove.push(index);
                }
            });

            // Draw solar flare effect
            if (this.solarFlare.active) {
                ctx.fillStyle = "rgba(255, 100, 0, 0.3)";
                ctx.fillRect(0, 0, this.ui.canvas.width, this.ui.canvas.height);
            }

            // Remove elements after iteration (updated for safety)
            // Sort and remove in reverse order to prevent index shifting
            enemiesToRemove.sort((a, b) => b - a).forEach(index => {
                if (index >= 0 && index < this.enemies.length) this.enemies.splice(index, 1);
            });
            projectilesToRemove.sort((a, b) => b - a).forEach(index => {
                if (index >= 0 && index < this.projectiles.length) this.projectiles.splice(index, 1);
            });
            coinsToRemove.sort((a, b) => b - a).forEach(index => {
                if (index >= 0 && index < this.coins.length) this.coins.splice(index, 1);
            });
            asteroidsToRemove.sort((a, b) => b - a).forEach(index => {
                if (index >= 0 && index < this.asteroids.length) this.asteroids.splice(index, 1);
            });
            debrisToRemove.sort((a, b) => b - a).forEach(index => {
                if (index >= 0 && index < this.debris.length) this.debris.splice(index, 1);
            });
            towersToRemoveFinal.sort((a, b) => b - a).forEach(index => {
                if (index >= 0 && index < this.towers.length) this.towers.splice(index, 1);
            });

            // Check game over condition (redundant check)
            if (this.playerHealth <= 0) {
                this.gameOver = true;
                this.ui.endGame(backgroundMusic);
                this.ui.sounds.shipDestroy.play().catch((error) => console.error("Error playing ship destroy sound:", error));
            }
        }
        }

        class Game {
          constructor() {
            this.ui = new GameUI();
            this.logic = new GameLogic(this.ui);
            this.animationFrameId = null;
            this.isPaused = false;
          }

          prepareGame() {
            window.addEventListener("resize", () => this.ui.resizeCanvas());
            this.ui.resizeCanvas();
            this.assignButtons();
          }

          startGame() {
            this.logic.reset();
            this.ui.startGame();
            if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
            this.gameLoop(0);
          }

          gameLoop(timestamp) {
            if (this.logic.gameOver) return;

            const deltaTime = timestamp - this.logic.lastFrameTime;
            if (deltaTime > this.logic.frameInterval) {
              this.logic.update(timestamp);
              this.logic.draw();
              this.logic.lastFrameTime = timestamp;
            }

            if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = requestAnimationFrame(this.gameLoop.bind(this));
          }

          pause() {
            this.isPaused = true;
            cancelAnimationFrame(this.animationFrameId);
          }

          resume() {
            this.isPaused = false;
            this.gameLoop(0);
          }

          assignButtons() {
            const addButtonListener = (id, callback) => {
              const button = document.getElementById(id);
              if (button) {
                button.addEventListener("click", callback);
                button.addEventListener("touchstart", (e) => {
                  e.preventDefault();
                  callback();
                }, { passive: false });
              }
            };

            addButtonListener("play-button", () => this.startGame());
            addButtonListener("settings-button", () => this.ui.settings());
            addButtonListener("instructions-button", () => this.ui.instructions());
            addButtonListener("play-again-button", () => this.startGame());
            addButtonListener("settings-back-button", () => this.ui.mainMenu());
            addButtonListener("instructions-back-button", () => this.ui.mainMenu());
            addButtonListener("main-menu-button", () => this.ui.mainMenu());
            addButtonListener("game-menu-button", () => this.ui.mainMenu());
            addButtonListener("game-restart-button", () => this.startGame());
            addButtonListener("game-instructions-button", () => {
              this.pause();
              this.ui.instructions();
              const backButton = document.getElementById("instructions-back-button");
              const handler = () => {
                this.ui.swapToScreen(this.ui.gameScreen);
                this.resume();
                backButton.removeEventListener("click", handler);
                backButton.removeEventListener("touchstart", handler);
              };
              backButton.addEventListener("click", handler);
              backButton.addEventListener("touchstart", (e) => {
                e.preventDefault();
                handler();
              }, { passive: false });
            });
          }
        }

        const game = new Game();
        game.prepareGame();
      });
    </script>
  </body>
</html>